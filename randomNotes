
c++1z <- nieformalna flaga standartu c++17
c++14
c++11


te specjalizacje szablonów dla voida są dostępne od c++14 
bo vector<bool> 

specjalizacje szablonów funkcji

inline vs. multiple definition?


Nie istnieją częściowe specjalizacje funkcji
4 linijka slajd Overloading vs specializations

funkcje składowe szablonów też nie mogą być częśćiowo specjalizowane

Zamiast częściowej specjalizacji można zrobić przeciążenie funkcji
Błędy związane z przeciążeniami są przyjemniejsze niż błędy linkera.

Nie musimy zmieniać nagłówków

Kolejność w cpp ma znaczenie

SFINAE  /polska wymowa sfinej sfineing

Substitution Failure Is Not An Error

enable_if
w booscie było też disable_if ale w c++11 nie jest już tak przydatne

...  <- dowolna ilość wartości typu tego co poprzedza trzy kropki


enable_if_t nie jest fajne bo daje nieczytelne błędy
lepiej używać std::enable_if

-----------------------------------------------------------------
Slajd Expression SINAE and void_t

aaa -> decltype(bbb)    -------------- decltype(bbb) jest typem ale zapisane na końcu żeby było czytelniej.


declval<U>() sprawia że mamy wartość z typu na którym możemy operować


SFINAE działa tylko na depended context  

SFINAE nie działa jak wszystkie typy są znane

dlatego musimy wprowadzić dodatkowe zmienne np U


duckt typing jak wygląda jak kaczka to jest kaczka


decltype zwraca typ zwracany przez wyrażenie podane w argumencie

-------------------------------------------------------------------



Referencja nie jest dedukowana,
tzn. jeśli nie zapiszemy, że coś jest refeferencją to to na pewno nie będzie referencją


decltype podaje tylko zadeklarowany typ obiektu
Jak podamy mu wyrażenie to dostaniemy typ wyrażenias

ale poda nam referencję gdy wyrażenie zwróci Lvalue
czyli wyrażenie które może być po lewej stronie przypisania
np.

int arr[10];
static_assert(std::is_same<decltype(arr[0]), int &> :: value);
static_assert(std::is_same<decltype((x)), int &> :: value);
tutaj x nie zwraca referencji ale x w nawiasach jest Lvalue
zatem typ który poda decltype będzie referencją

Bo decltype jest wyspecyfikowany dla nazw i wyrażeń

Po return nie dajemy nawiasów okrągłych bo to może zminić semantykę programu


--------------------------------------------

reference collapsing


R and L value reference

forwarding references





